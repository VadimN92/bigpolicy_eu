{"version":3,"file":"name.list.service.spec.js","sourceRoot":"","sources":["../../../Users/rsiryk/dev/BP/qa-dev/tmp/broccoli_type_script_compiler-input_base_path-iwlepOBb.tmp/0/src/app/shared/name-list/name.list.service.spec.ts"],"names":[],"mappings":";AAAA,qBAA4C,eAAe,CAAC,CAAA;AAC5D,qBAAuG,eAAe,CAAC,CAAA;AACvH,wBAA4B,uBAAuB,CAAC,CAAA;AACpD,2BAA2B,iBAAiB,CAAC,CAAA;AAE7C,kCAAgC,qBAAqB,CAAC,CAAA;AAEtD;IACE,QAAQ,CAAC,kBAAkB,EAAE;QAC3B,IAAI,eAAgC,CAAC;QACrC,IAAI,OAAoB,CAAC;QACzB,IAAI,eAAoB,CAAC;QAEzB,UAAU,CAAC;YACT,IAAI,QAAQ,GAAG,yBAAkB,CAAC,gBAAgB,CAAC;gBACjD,qBAAc;gBACd,mCAAe;gBACf,yBAAkB;gBAClB,qBAAW;gBACX,cAAO,CAAC,WAAI,EAAE;oBACZ,UAAU,EAAE,UAAS,OAA0B,EAAE,cAAkC;wBACjF,MAAM,CAAC,IAAI,WAAI,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;oBAC3C,CAAC;oBACD,IAAI,EAAE,CAAC,qBAAW,EAAE,yBAAkB,CAAC;iBACxC,CAAC;aACH,CAAC,CAAC;YACH,eAAe,GAAG,QAAQ,CAAC,GAAG,CAAC,mCAAe,CAAC,CAAC;YAChD,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,qBAAW,CAAC,CAAC;YAEpC,IAAI,UAAe,CAAC;YACpB,OAAO,CAAC,WAAW,CAAC,SAAS,CAAC,UAAC,CAAM,IAAK,OAAA,UAAU,GAAG,CAAC,EAAd,CAAc,CAAC,CAAC;YAC1D,eAAe,GAAG,eAAe,CAAC,GAAG,EAAE,CAAC;YACxC,UAAU,CAAC,WAAW,CAAC,IAAI,eAAQ,CAAC,IAAI,sBAAe,CAAC,EAAE,IAAI,EAAE,wBAAwB,EAAE,CAAC,CAAC,CAAC,CAAC;QAChG,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,6CAA6C,EAAE;YAChD,MAAM,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,uBAAU,CAAC,CAAC,CAAC;QAC3D,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,iDAAiD,EAAE;YACpD,IAAI,KAAU,CAAC;YACf,eAAe,CAAC,SAAS,CAAC,UAAC,IAAS,IAAK,OAAA,KAAK,GAAG,IAAI,EAAZ,CAAY,CAAC,CAAC;YACvD,MAAM,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC,CAAC;QAChD,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAtCe,YAAI,OAsCnB,CAAA","sourcesContent":["import { provide, ReflectiveInjector } from '@angular/core';\nimport { BaseRequestOptions, ConnectionBackend, Http, HTTP_PROVIDERS, Response, ResponseOptions } from '@angular/http';\nimport { MockBackend } from '@angular/http/testing';\nimport { Observable } from 'rxjs/Observable';\n\nimport { NameListService } from './name-list.service';\n\nexport function main() {\n  describe('NameList Service', () => {\n    let nameListService: NameListService;\n    let backend: MockBackend;\n    let initialResponse: any;\n\n    beforeEach(() => {\n      let injector = ReflectiveInjector.resolveAndCreate([\n        HTTP_PROVIDERS,\n        NameListService,\n        BaseRequestOptions,\n        MockBackend,\n        provide(Http, {\n          useFactory: function(backend: ConnectionBackend, defaultOptions: BaseRequestOptions) {\n            return new Http(backend, defaultOptions);\n          },\n          deps: [MockBackend, BaseRequestOptions]\n        }),\n      ]);\n      nameListService = injector.get(NameListService);\n      backend = injector.get(MockBackend);\n\n      let connection: any;\n      backend.connections.subscribe((c: any) => connection = c);\n      initialResponse = nameListService.get();\n      connection.mockRespond(new Response(new ResponseOptions({ body: '[\"Dijkstra\", \"Hopper\"]' })));\n    });\n\n    it('should return an Observable when get called', () => {\n      expect(initialResponse).toEqual(jasmine.any(Observable));\n    });\n\n    it('should resolve to list of names when get called', () => {\n      let names: any;\n      initialResponse.subscribe((data: any) => names = data);\n      expect(names).toEqual(['Dijkstra', 'Hopper']);\n    });\n  });\n}\n"]}